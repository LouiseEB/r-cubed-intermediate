{
  "hash": "46bd9cea391977c4cf737a71ead909af",
  "result": {
    "markdown": "# Extra material {#sec-extra-material}\n\n## Functionals and for loops {#sec-alternative-loop-explanation}\n\nThe concept of functional programming can be difficult to grasp. As an\nalternative to the above explanation, one could also explain functional\nprogramming in relation to what it enables. For example, imagine that\nyou have a vector and would like to investigate whether any given number\ninside this vector is above 5. This can be accomplished using a variety\nof programming styles. First, we could create a function to check\nwhether a given number is above 5, and manually check each element of\nthe vector:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create vector of 10 numbers\nnumbers <- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n\n# Function to check if a number is above 5\nover_five <- function(number) {\n  if (number > 5) {\n    return(TRUE)\n  } else {\n    return(FALSE)\n  }\n}\n\n# Check each element\nover_five(numbers[1])\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> [1] FALSE\n```\n:::\n\n```{.r .cell-code}\nover_five(numbers[2])\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> [1] FALSE\n```\n:::\n\n```{.r .cell-code}\nover_five(numbers[3])\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> [1] FALSE\n```\n:::\n\n```{.r .cell-code}\nover_five(numbers[4])\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> [1] FALSE\n```\n:::\n\n```{.r .cell-code}\nover_five(numbers[5])\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> [1] FALSE\n```\n:::\n\n```{.r .cell-code}\nover_five(numbers[6])\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> [1] TRUE\n```\n:::\n\n```{.r .cell-code}\nover_five(numbers[7])\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> [1] TRUE\n```\n:::\n\n```{.r .cell-code}\nover_five(numbers[8])\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> [1] TRUE\n```\n:::\n\n```{.r .cell-code}\nover_five(numbers[9])\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> [1] TRUE\n```\n:::\n\n```{.r .cell-code}\nover_five(numbers[10])\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> [1] TRUE\n```\n:::\n:::\n\n\nSuch an approach is verbose, not \"functional\" in style, and very\ninflexible. Imagine if the vector had contained 100 numbers instead of\n10. In such a case, it would have been unreasonable to manually check\neach element. As an alternative we could accomplish the same by using a\nfor loop:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Initialize a vector to capture the output in the for loop\noutput <- vector(\"logical\", length = length(numbers))\n\n# Use seq_along to get for loop to start from 1 and end at the end of numbers\nfor (item in seq_along(numbers)) {\n  output[item] <- over_five(numbers[item])\n}\noutput\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#>  [1] FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE\n```\n:::\n:::\n\n\nThis for loop is taking each item from numbers, using `over_five()` on\nit, and then saving the output into the object `output`. So this loop\nallows us to do the same as we did manually, but more precisely and with\nless code. If the vector has more items or less, it doesn't matter to\nthe for loop since it will run no matter the length. You might notice\nalready that there are several technical things going on, like the use\nof `vector()`, `seq_along()`, and `output[item]`. We won't explain them\nhere, but this is meant to highlight that loops aren't easy to actually\nuse properly.\n\nFor some situations, for loops are the perfect solution. However, they\nare not R's strength, but rather functional programming is. In this\ncase, we replace the for loop with the functional `map()`, which would\nmake the code shorter and more robust.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n#> ── Attaching core tidyverse packages ──────────── tidyverse 2.0.0 ──\n#> ✔ dplyr     1.1.2     ✔ readr     2.1.4\n#> ✔ forcats   1.0.0     ✔ stringr   1.5.0\n#> ✔ ggplot2   3.4.2     ✔ tibble    3.2.1\n#> ✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n#> ✔ purrr     1.0.1     \n#> ── Conflicts ────────────────────────────── tidyverse_conflicts() ──\n#> ✖ dplyr::filter() masks stats::filter()\n#> ✖ dplyr::lag()    masks stats::lag()\n#> ℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n:::\n\n```{.r .cell-code}\n# Functional\nmap(numbers, over_five)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> [[1]]\n#> [1] FALSE\n#> \n#> [[2]]\n#> [1] FALSE\n#> \n#> [[3]]\n#> [1] FALSE\n#> \n#> [[4]]\n#> [1] FALSE\n#> \n#> [[5]]\n#> [1] FALSE\n#> \n#> [[6]]\n#> [1] TRUE\n#> \n#> [[7]]\n#> [1] TRUE\n#> \n#> [[8]]\n#> [1] TRUE\n#> \n#> [[9]]\n#> [1] TRUE\n#> \n#> [[10]]\n#> [1] TRUE\n```\n:::\n:::\n\n\nThis works great as is, but sometimes you might not need to create a new\nfunction to use inside of `map()`. Instead we could use an anonymous\nfunction with either `function()` or `~`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Anonymous function\nmap(numbers, function(x) if (x > 5) TRUE else FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> [[1]]\n#> [1] FALSE\n#> \n#> [[2]]\n#> [1] FALSE\n#> \n#> [[3]]\n#> [1] FALSE\n#> \n#> [[4]]\n#> [1] FALSE\n#> \n#> [[5]]\n#> [1] FALSE\n#> \n#> [[6]]\n#> [1] TRUE\n#> \n#> [[7]]\n#> [1] TRUE\n#> \n#> [[8]]\n#> [1] TRUE\n#> \n#> [[9]]\n#> [1] TRUE\n#> \n#> [[10]]\n#> [1] TRUE\n```\n:::\n\n```{.r .cell-code}\n# Anonymous function (with shortcut)\nmap(numbers, ~ if (.x > 5) TRUE else FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> [[1]]\n#> [1] FALSE\n#> \n#> [[2]]\n#> [1] FALSE\n#> \n#> [[3]]\n#> [1] FALSE\n#> \n#> [[4]]\n#> [1] FALSE\n#> \n#> [[5]]\n#> [1] FALSE\n#> \n#> [[6]]\n#> [1] TRUE\n#> \n#> [[7]]\n#> [1] TRUE\n#> \n#> [[8]]\n#> [1] TRUE\n#> \n#> [[9]]\n#> [1] TRUE\n#> \n#> [[10]]\n#> [1] TRUE\n```\n:::\n:::\n\n\n## Debugging functions\n\nDebugging is one of activities that seems really scary and difficult,\nbut once you try it and use it, is not nearly as intimidating as it\nseemed. To debug, which means to find and fix problems in your code,\nthere are several ways, the simplest of which is by inserting the\n`browser()` function into the the start of your function, re-running the\nfunction by either manually running it or using source with\n{{< var keybind.source >}}, and using it again.\n\nFor instance, we have a function like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_debugging <- function(number) {\n  number + number\n}\n```\n:::\n\n\nTo start the debugger, insert the `browser()` function into your\nfunction:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_debugging <- function(number) {\n  browser()\n  number + number\n}\n```\n:::\n\n\nAnd re-run and use the function again, which will pop up a new debugging\npanel in RStudio. Sadly, we can't show this on the website since it only\nworks in RStudio (we may add a video as some point). When you are in the\ndebugger will open up and it will show a few things:\n\n<!-- TODO: eventually add an image or video.. but for next year. -->\n\n-   A yellow line will highlight the code in the function, along with a\n    green arrow on the left of the line number.\n-   The Console will now start with `Browse[1]>` and will have text like\n    `debug at ...`.\n-   There will be new buttons on the top of the Console like \"Next\",\n    \"Continue\", and \"Stop\".\n-   The Environment pane will be empty and will say \"Traceback\".\n\n<!-- TODO: Add image or video of this or extend it from previous video? -->\n\n<!-- TODO: Image of debugging changes, with descriptions -->\n\nIn this mode you can really investigate what is happening with your code\nand how to fix it. The way to figure out what's wrong is by running the\ncode bit by bit. This debug environment is empty except for the actions\nthat occur within it, so it really can help figure things out.\n\n## Non-standard evaluation (NSE)\n\nWriting your own functions that use `{tidyverse}` functions, you may\neventually encounter an error that might not be very easy to figure out.\nHere's an example where you want to use your own arguments in\n`filter()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_nse <- function(data, filter_condition) {\n  data %>%\n    dplyr::filter(filter_condition)\n}\n\nCO2 %>%\n  tibble() %>%\n  test_nse(conc > 100)\n```\n\n::: {.cell-output .cell-output-error}\n```\n#> Error in `dplyr::filter()`:\n#> ℹ In argument: `filter_condition`.\n#> Caused by error:\n#> ! object 'conc' not found\n```\n:::\n:::\n\n\nThe error occurs of something called \"[non-standard\nevaluation](https://adv-r.had.co.nz/Computing-on-the-language.html)\" (or\nNSE). NSE is a feature of R and is used quite a lot throughout R (e.g.\n`library()`), but is especially used in the `{tidyverse}` packages. It's\none of the first things computer scientists complain about when they use\nR, because it is such a foreign thing in other programming languages.\nBut NSE is what allows you to use formulas (e.g. `y ~ x + x2` in\nmodeling) or allows you to type out `select(Gender, BMI)` or\n`library(purrr)`. In \"standard evaluation\", these would instead be\n`select(\"Gender\", \"BMI\")` or `library(\"purrr\")`. So NSE gives\nflexibility and ease of use for the user (we don't have to type quotes\nevery time) when doing data analysis, but can give some headaches when\nprogramming in R, like when making functions. There's more detail about\nthis on the [dplyr\nwebsite](https://dplyr.tidyverse.org/articles/programming.html#warm-up),\nwhich will give a few options to deal with NSE while programming with\n`{tidyverse}` packages, the simplest of which is to wrap the argument\nwith `{{}}`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_nse <- function(data, filter_condition) {\n  data %>%\n    dplyr::filter({{ filter_condition }})\n}\n\nCO2 %>%\n  tibble() %>%\n  test_nse(conc > 100)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> # A tibble: 72 × 5\n#>    Plant Type   Treatment   conc uptake\n#>    <ord> <fct>  <fct>      <dbl>  <dbl>\n#>  1 Qn1   Quebec nonchilled   175   30.4\n#>  2 Qn1   Quebec nonchilled   250   34.8\n#>  3 Qn1   Quebec nonchilled   350   37.2\n#>  4 Qn1   Quebec nonchilled   500   35.3\n#>  5 Qn1   Quebec nonchilled   675   39.2\n#>  6 Qn1   Quebec nonchilled  1000   39.7\n#>  7 Qn2   Quebec nonchilled   175   27.3\n#>  8 Qn2   Quebec nonchilled   250   37.1\n#>  9 Qn2   Quebec nonchilled   350   41.8\n#> 10 Qn2   Quebec nonchilled   500   40.6\n#> # ℹ 62 more rows\n```\n:::\n\n```{.r .cell-code}\nCO2 %>%\n  tibble() %>%\n  test_nse(uptake < 30)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n#> # A tibble: 43 × 5\n#>    Plant Type   Treatment   conc uptake\n#>    <ord> <fct>  <fct>      <dbl>  <dbl>\n#>  1 Qn1   Quebec nonchilled    95   16  \n#>  2 Qn2   Quebec nonchilled    95   13.6\n#>  3 Qn2   Quebec nonchilled   175   27.3\n#>  4 Qn3   Quebec nonchilled    95   16.2\n#>  5 Qc1   Quebec chilled       95   14.2\n#>  6 Qc1   Quebec chilled      175   24.1\n#>  7 Qc2   Quebec chilled       95    9.3\n#>  8 Qc2   Quebec chilled      175   27.3\n#>  9 Qc3   Quebec chilled       95   15.1\n#> 10 Qc3   Quebec chilled      175   21  \n#> # ℹ 33 more rows\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}