# Creating your own function {#functions}

![](https://img.shields.io/badge/document%20status-in%20progress-red?style=flat-square)

```{r, eval=TRUE, child="resources/preamble.Rmd"}
```

`r '<!-- '`

Day 2 morning (8:30, lunch at 12:00 --- ~3.5 hrs, with one big break, one small one during exercise):

- creating functions
    - and when using tidyverse functions
- package dependency
    - use_package
    - ::
- Moving functions into own R file
    - Then either sourcing or load_all (maybe not get into that for them)
- debugging in functions
    - breaks in RStudio?
    - basics like print.

- Use a custom function in the advanced dplyr, to link to previous?

## Misc

Before we begin, create a new file for this session. Make sure you are in the
correct R Project.

```{r create-session-file, eval=FALSE}
usethis::use_r("efficiency-session")
```

As mentioned before, all actions in R are functions. For instance, the `+` is a
function, `mean()` is a function, `[]` is a function, and so on. So creating
your functions can make doing your work easier and more efficient. Making
functions always has a basic structure of:

1. Giving a name to the function (e.g. `mean`).
2. Starting the function call using `function()`, assigning it to the name with
`<-`. This tells R that the name is a function object.
3. Optionally providing arguments to give to the function call, for instance
`function(arg1, arg2, arg3)`. 
4. Filling out the body of the function, with the arguments (if any) contained
inside, that does some action.
5. Optionally, but strongly encouraged, use `return` to indicate what you want 
the function to output.

While there is no minimum or maximum number of arguments you can provide for a
function (e.g. you could have zero or dozens of arguments), its good practice
for yourself and for others if you have as few arguments as possible to get
the job done.

So, the structure is:

```{r function-structure, eval=FALSE}
name <- function(arg1, arg2) {
    # body of function
    ... code ....
    return(output)
}
```

... and an example:

```{r create-add-function}
add_nums <- function(num1, num2) {
    added <- num1 + num2
    return(added)
}
```

You can use the new function by running the above code and writing out your new 
function, with arguments to give it.

```{r call-function}
add_nums(1, 2)
```

The function name is fairly good... `add_nums` can be read as "add numbers".
It's also good practice to add some formal documentation to the function. Use
the "Insert Roxygen Skeleton" in the "Code" menu list (or by typing
`Ctrl-Shift-Alt-R`) and you can add template documentation right above the
function. It looks like:

```{r roxygen-docs-1}
#' Title
#'
#' @param num1 
#' @param num2 
#'
#' @return
#' @export
#'
#' @examples
add_nums <- function(num1, num2) {
    added <- num1 + num2
    return(added)
}
```

In the `Title` area, this is where you type out a brief sentence or several words 
that describe the function. Creating a new paragraph below this line allows you 
to add a more detailed description. The other items are:

- `@param num` lines are to describe what each argument is for.
- `@return` describes what output the function provides. Is it a data.frame? A plot? 
What else does the output give?
- `@export` tells R that this function should be accessible to the user of your
package. Delete it for non-package functions.
- `@examples` lines below this are used to show examples of how to use the function.
Very useful when making packages, but not really in this case.

```{r roxygen-docs-2}
#' Add two numbers together.
#'
#' This is just an example function to show how to create one.
#'
#' @param num1 A number here.
#' @param num2 A number here.
#'
#' @return Returns the sum of the two numbers.
#'
add_nums <- function(num1, num2) {
    added <- num1 + num2
    return(added)
}
```

### Functions to wrangle

Let's get to something you might actually do in a data analysis project. Let's 
suppose you want to compare the mean and standard deviation of several variables
by a given categorical variable, such as `SurveyYr` or `Gender`, that you might
want to include as an exploratory table in a report or document. Without making 
a function, you would normally run a series of functions for each of the categorical
variables. For instance:

```{r to-wrangle}
NHANES %>% 
    select(Gender, BMI, TotChol, Pulse, BPSysAve, BPDiaAve) %>% 
    gather(Measurement, Value, -Gender) %>% 
    na.omit() %>% 
    group_by(Gender, Measurement) %>% 
    summarise(Mean = round(mean(Value), 2),
              SD = round(sd(Value), 2),
              MeanSD = str_c(Mean, " (", SD, ")")) %>% 
    select(-Mean, -SD) %>% 
    spread(Gender, MeanSD)
```

Nice, but now if we did it for `SurveyYr` instead of `Gender`? We would have to 
replace all `Gender` variables with `SurveyYr`. Instead, let's create a function.
First, copy and paste the code above into a function structure.

```{r base-function-template, eval=FALSE}
mean_sd_by_group <- function() {
    by_group_output <- NHANES %>% 
        select(Gender, BMI, TotChol, Pulse, BPSysAve, BPDiaAve) %>% 
        gather(Measurement, Value, -Gender) %>% 
        na.omit() %>% 
        group_by(Gender, Measurement) %>% 
        summarise(Mean = round(mean(Value), 2),
                  SD = round(sd(Value), 2),
                  MeanSD = str_c(Mean, " (", SD, ")")) %>% 
        select(-Mean, -SD) %>% 
        spread(Gender, MeanSD)
    return(by_group_output)
}
```

Great, now we need to add in arguments and place the arguments in the correct 
locations. (I tend to put a `.` before my arguments to differentiate them from 
other variables.)

```{r add-function-arguments, error=TRUE}
mean_sd_by_group <- function(.dataset, .groupvar) {
    by_group_output <- .dataset %>% 
        select(.groupvar, BMI, TotChol, Pulse, BPSysAve, BPDiaAve) %>% 
        gather(Measurement, Value, -.groupvar) %>% 
        na.omit() %>% 
        group_by(.groupvar, Measurement) %>% 
        summarise(Mean = round(mean(Value), 2),
                  SD = round(sd(Value), 2),
                  MeanSD = str_c(Mean, " (", SD, ")")) %>% 
        select(-Mean, -SD) %>% 
        spread(.groupvar, MeanSD)
    return(by_group_output)
}
mean_sd_by_group(NHANES, Gender)
```

What happened? We had an error. We've encountered a problem due to
"[non-standard evaluation]" (or NSE). NSE is very commonly used in most tidyverse
packages as well as throughout base R. It's one of the first things computer 
scientists complain about when they use R, because it is such a foreign thing
in other programming languages. But NSE is what allows you to use formulas (e.g.
`y ~ x + x2` in modelling) or allows you to type out `select(Gender, BMI)`. In
other programming languages, it would be `select("Gender", "BMI")`. It gives a lot
of flexibility to use for doing data analysis, but can give some headaches when
programming in R. So instead we have to use quotes instead and use the `_at()` 
combined with `vars()` version of dplyr functions. The tidyr functions `gather`
and `spread` don't require these changes.

[non-standard evaluation]: https://adv-r.had.co.nz/Computing-on-the-language.html

```{r add-function-arguments-error, error=TRUE}
mean_sd_by_group <- function(.dataset, .groupvar) {
    by_group_output <- .dataset %>% 
        select_at(vars(.groupvar, BMI, TotChol, Pulse, BPSysAve, BPDiaAve)) %>% 
        gather(Measurement, Value, -.groupvar) %>% 
        na.omit() %>% 
        group_by_at(vars(.groupvar, Measurement)) %>% 
        summarise(Mean = round(mean(Value), 2),
                  SD = round(sd(Value), 2),
                  MeanSD = str_c(Mean, " (", SD, ")")) %>% 
        select(-Mean, -SD) %>% 
        spread(.groupvar, MeanSD)
    return(by_group_output)
}
mean_sd_by_group(NHANES, "Gender")
```

Now we can also use other categorical variables:

```{r use-other-category-vars}
mean_sd_by_group(NHANES, "SurveyYr")
mean_sd_by_group(NHANES, "Diabetes")
```

Nifty eh? If you want a fancy table when using R Markdown, use the
`kable::knitr` function.

```{r fancy-table}
mean_sd_by_group(NHANES, "Diabetes") %>% 
    knitr::kable(caption = "Mean and SD of some measurements by Diabetes status.")
```

A massive advantage of using functions is that if you want to make a change to all
your code, you can very easily do it in the R function and it will change all 
your other code too!

If you want to make sure that who ever uses your function will not use a wrong 
argument, you can use "defensive programming" via the `stopifnot()` function.
This forces the code to only work if `.groupvar` is a character (e.g. `"this"`)
argument.

```{r add-function-stopifnot}
mean_sd_by_group <- function(.dataset, .groupvar) {
    stopifnot(is.character(.groupvar))
    by_group_output <- .dataset %>% 
        select_at(vars(.groupvar, BMI, TotChol, Pulse, BPSysAve, BPDiaAve)) %>% 
        gather(Measurement, Value, -.groupvar) %>% 
        na.omit() %>% 
        group_by_at(vars(.groupvar, Measurement)) %>% 
        summarise(Mean = round(mean(Value), 2),
                  SD = round(sd(Value), 2),
                  MeanSD = str_c(Mean, " (", SD, ")")) %>% 
        select(-Mean, -SD) %>% 
        spread(.groupvar, MeanSD)
    return(by_group_output)
}
```

A good practice to use after you've created your function is to explicitly indicate 
which functions come from which package, since you shouldn't use `library` calls
in your function. We do this by using the `packagename::function_name` format 
(you don't need to do this for base R functions). Plus, let's add some
documentation! (`Ctrl-Alt-Shift-R`).

```{r explicit-function-call}
#' Calculate mean and standard deviation by a grouping variable.
#'
#' @param .dataset The dataset
#' @param .group_variable Variable to group by
#'
#' @return Output a data frame.
#'
mean_sd_by_group <- function(.dataset, .groupvar) {
    stopifnot(is.character(.groupvar))
    by_group_output <- .dataset %>% 
        dplyr::select_at(dplyr::vars(.groupvar, BMI, 
                                     TotChol, Pulse, BPSysAve, BPDiaAve)) %>% 
        tidyr::gather(Measurement, Value, -.groupvar) %>% 
        na.omit() %>% 
        dplyr::group_by_at(dplyr::vars(.groupvar, Measurement)) %>% 
        dplyr::summarise(Mean = round(mean(Value), 2),
                  SD = round(sd(Value), 2),
                  MeanSD = stringr::str_c(Mean, " (", SD, ")")) %>% 
        dplyr::select(-Mean, -SD) %>% 
        tidyr::spread(.groupvar, MeanSD)
    return(by_group_output)
}
```

### Functions to plot

Let's do this for plots too, since we'll likely be making lots of those! Let's
say we are doing multiple scatter plots, and we've already made a nice theme. 
But we want to create several scatter plots. The non-function code:

```{r scatter-plot}
ggplot(NHANES, aes(x = Height, y = Weight, colour = Gender)) +
    geom_point(size = 2, alpha = 0.3) +
    scale_colour_viridis_d(option = "B", begin = 0.2, end = 0.7) +
    theme_minimal() +
    theme(text = element_text(colour = "grey40"))
```

Like before, maybe we want to see the scatter plot by different variables. So let's 
get it into function form:

```{r plot-function-template, eval=FALSE}
plot_scatter_by_group <- function() {
    scatter_plot <- ggplot(NHANES, aes(x = Height, y = Weight, 
                                       colour = Gender)) +
        geom_point(size = 2, alpha = 0.3) +
        scale_colour_viridis_d(option = "B", begin = 0.2, end = 0.7) +
        theme_minimal() +
        theme(text = element_text(colour = "grey40"))
    return(scatter_plot)
}
```

Then let's add in the arguments.

```{r plot-function-arguments, eval=FALSE}
plot_scatter_by_group <- function(.dataset, .xvar, .yvar, .groupvar) {
    scatter_plot <- ggplot(.dataset, aes(x = .xvar, y = .yvar, 
                                         colour = .groupvar)) +
        geom_point(size = 2, alpha = 0.3) +
        scale_colour_viridis_d(option = "B", begin = 0.2, end = 0.7) +
        theme_minimal() +
        theme(text = element_text(colour = "grey40"))
    return(scatter_plot)
}
```


Like the dplyr code above, this function won't work because it also uses NSE, so
ggplot2 will be confused by the `x = .xvar` since it will think you are asking
for the `.xvar` column in the dataset. So, we need to change `aes()` to
`aes_string()` to force ggplot2 to read `.xvar` as a character string that is
the name of the column you want to plot.

```{r plot-function-aes-string}
plot_scatter_by_group <- function(.dataset, .xvar, .yvar, .groupvar) {
    scatter_plot <- ggplot(.dataset, aes_string(x = .xvar, y = .yvar, 
                                                colour = .groupvar)) +
        geom_point(size = 2, alpha = 0.3) +
        scale_colour_viridis_d(option = "B", begin = 0.2, end = 0.7) +
        theme_minimal() +
        theme(text = element_text(colour = "grey40"))
    return(scatter_plot)
}
plot_scatter_by_group(NHANES, "Height", "Weight", "Gender")
```

Let's add in the `stopifnot`, `ggplot2::` explicit calls, and the roxygen
documentation (`Ctrl-Alt-Shift-R`):

```{r plot-function-finish-up}
#' Create a scatter plot with colouring by categorical variable.
#'
#' @param .dataset Data to plot.
#' @param .xvar Variable for the x axis.
#' @param .yvar Variable for the y axis.
#' @param .groupvar The variable to group/color by.
#'
#' @return Creates a ggplot.
#'
plot_scatter_by_group <- function(.dataset, .xvar, .yvar, .groupvar) {
    stopifnot(is.character(.xvar), is.character(.yvar), is.character(.groupvar))
    scatter_plot <- 
        ggplot2::ggplot(.dataset, ggplot2::aes_string(x = .xvar, y = .yvar, 
                                                      colour = .groupvar)) +
        ggplot2::geom_point(size = 2, alpha = 0.3) +
        ggplot2::scale_colour_viridis_d(option = "B", begin = 0.2, end = 0.7) +
        ggplot2::theme_minimal() +
        ggplot2::theme(text = ggplot2::element_text(colour = "grey40"))
    return(scatter_plot)
}
```

Now we can do other plots easily:

```{r use-plot-function-multiple-times}
plot_scatter_by_group(NHANES, "BMI", "TotChol", "SurveyYr")
plot_scatter_by_group(NHANES, "Poverty", "BMI", "Education")
plot_scatter_by_group(NHANES, "BMI", "BPSysAve", "Diabetes")
```

`r '-->'`
