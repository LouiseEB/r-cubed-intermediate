# Creating your own function {#functions}

![](https://img.shields.io/badge/document%20status-in%20progress-red?style=flat-square)

```{r, eval=TRUE, child="resources/preamble.Rmd"}
```

```{r}
knitr::opts_chunk$set(eval = FALSE)
```

Here we will cover the third block, "*Create final data*" in Figure \@ref(fig:diagram-overview-3)

```{r diagram-overview-3, fig.cap="Section of the overall workflow we will be covering.", fig.width=9}
diagram_overview(3)
```

`r '<!-- '`

Day 2 morning (8:30, lunch at 12:00 --- ~3.5 hrs, with one big break, one small one during exercise):

- debugging in functions
    - breaks in RStudio?
    - basics like print.

- Use a custom function in the advanced dplyr, to link to previous?

- deeper into dplyr
    - tidyselect helpers
    - across and where
    - regular expressions?
    - joins
    - Possible uses:
        - calculating mean
            - summarize across is numeric (select where is.numeric)
            - show off the ... here (like with na.rm)
            - Like for the RR or actigraph
        - Any time you think you would use a for loop, use this.
        
exercise:
    - activity, calculate minutes from start and end.

## Combining datasets


```{r, eval=FALSE}
library(dplyr)
user_1_fix %>% bind_cols(user_1_rr_fix)

# %>% 
#     rename(inter_beat_interval_seconds = ibi_s)
```


## Misc

Before we begin, create a new file for this session. Make sure you are in the
correct R Project.

```{r create-session-file, eval=FALSE}
usethis::use_r("efficiency-session")
```

### Functions to wrangle

Let's get to something you might actually do in a data analysis project. Let's 
suppose you want to compare the mean and standard deviation of several variables
by a given categorical variable, such as `SurveyYr` or `Gender`, that you might
want to include as an exploratory table in a report or document. Without making 
a function, you would normally run a series of functions for each of the categorical
variables. For instance:

```{r to-wrangle}
NHANES %>% 
    select(Gender, BMI, TotChol, Pulse, BPSysAve, BPDiaAve) %>% 
    gather(Measurement, Value, -Gender) %>% 
    na.omit() %>% 
    group_by(Gender, Measurement) %>% 
    summarise(Mean = round(mean(Value), 2),
              SD = round(sd(Value), 2),
              MeanSD = str_c(Mean, " (", SD, ")")) %>% 
    select(-Mean, -SD) %>% 
    spread(Gender, MeanSD)
```

Nice, but now if we did it for `SurveyYr` instead of `Gender`? We would have to 
replace all `Gender` variables with `SurveyYr`. Instead, let's create a function.
First, copy and paste the code above into a function structure.

```{r base-function-template, eval=FALSE}
mean_sd_by_group <- function() {
    by_group_output <- NHANES %>% 
        select(Gender, BMI, TotChol, Pulse, BPSysAve, BPDiaAve) %>% 
        gather(Measurement, Value, -Gender) %>% 
        na.omit() %>% 
        group_by(Gender, Measurement) %>% 
        summarise(Mean = round(mean(Value), 2),
                  SD = round(sd(Value), 2),
                  MeanSD = str_c(Mean, " (", SD, ")")) %>% 
        select(-Mean, -SD) %>% 
        spread(Gender, MeanSD)
    return(by_group_output)
}
```

Great, now we need to add in arguments and place the arguments in the correct 
locations. (I tend to put a `.` before my arguments to differentiate them from 
other variables.)

```{r add-function-arguments, error=TRUE}
mean_sd_by_group <- function(.dataset, .groupvar) {
    by_group_output <- .dataset %>% 
        select(.groupvar, BMI, TotChol, Pulse, BPSysAve, BPDiaAve) %>% 
        gather(Measurement, Value, -.groupvar) %>% 
        na.omit() %>% 
        group_by(.groupvar, Measurement) %>% 
        summarise(Mean = round(mean(Value), 2),
                  SD = round(sd(Value), 2),
                  MeanSD = str_c(Mean, " (", SD, ")")) %>% 
        select(-Mean, -SD) %>% 
        spread(.groupvar, MeanSD)
    return(by_group_output)
}
mean_sd_by_group(NHANES, Gender)
```

What happened? We had an error. We've encountered a problem due to
"[non-standard evaluation]" (or NSE). NSE is very commonly used in most tidyverse
packages as well as throughout base R. It's one of the first things computer 
scientists complain about when they use R, because it is such a foreign thing
in other programming languages. But NSE is what allows you to use formulas (e.g.
`y ~ x + x2` in modelling) or allows you to type out `select(Gender, BMI)`. In
other programming languages, it would be `select("Gender", "BMI")`. It gives a lot
of flexibility to use for doing data analysis, but can give some headaches when
programming in R. So instead we have to use quotes instead and use the `_at()` 
combined with `vars()` version of dplyr functions. The tidyr functions `gather`
and `spread` don't require these changes.

[non-standard evaluation]: https://adv-r.had.co.nz/Computing-on-the-language.html

```{r add-function-arguments-error, error=TRUE}
mean_sd_by_group <- function(.dataset, .groupvar) {
    by_group_output <- .dataset %>% 
        select_at(vars(.groupvar, BMI, TotChol, Pulse, BPSysAve, BPDiaAve)) %>% 
        gather(Measurement, Value, -.groupvar) %>% 
        na.omit() %>% 
        group_by_at(vars(.groupvar, Measurement)) %>% 
        summarise(Mean = round(mean(Value), 2),
                  SD = round(sd(Value), 2),
                  MeanSD = str_c(Mean, " (", SD, ")")) %>% 
        select(-Mean, -SD) %>% 
        spread(.groupvar, MeanSD)
    return(by_group_output)
}
mean_sd_by_group(NHANES, "Gender")
```

Now we can also use other categorical variables:

```{r use-other-category-vars}
mean_sd_by_group(NHANES, "SurveyYr")
mean_sd_by_group(NHANES, "Diabetes")
```

Nifty eh? If you want a fancy table when using R Markdown, use the
`kable::knitr` function.

```{r fancy-table}
mean_sd_by_group(NHANES, "Diabetes") %>% 
    knitr::kable(caption = "Mean and SD of some measurements by Diabetes status.")
```

A massive advantage of using functions is that if you want to make a change to all
your code, you can very easily do it in the R function and it will change all 
your other code too!

If you want to make sure that who ever uses your function will not use a wrong 
argument, you can use "defensive programming" via the `stopifnot()` function.
This forces the code to only work if `.groupvar` is a character (e.g. `"this"`)
argument.

```{r add-function-stopifnot}
mean_sd_by_group <- function(.dataset, .groupvar) {
    stopifnot(is.character(.groupvar))
    by_group_output <- .dataset %>% 
        select_at(vars(.groupvar, BMI, TotChol, Pulse, BPSysAve, BPDiaAve)) %>% 
        gather(Measurement, Value, -.groupvar) %>% 
        na.omit() %>% 
        group_by_at(vars(.groupvar, Measurement)) %>% 
        summarise(Mean = round(mean(Value), 2),
                  SD = round(sd(Value), 2),
                  MeanSD = str_c(Mean, " (", SD, ")")) %>% 
        select(-Mean, -SD) %>% 
        spread(.groupvar, MeanSD)
    return(by_group_output)
}
```

A good practice to use after you've created your function is to explicitly indicate 
which functions come from which package, since you shouldn't use `library` calls
in your function. We do this by using the `packagename::function_name` format 
(you don't need to do this for base R functions). Plus, let's add some
documentation! (`Ctrl-Alt-Shift-R`).

```{r explicit-function-call}
#' Calculate mean and standard deviation by a grouping variable.
#'
#' @param .dataset The dataset
#' @param .group_variable Variable to group by
#'
#' @return Output a data frame.
#'
mean_sd_by_group <- function(.dataset, .groupvar) {
    stopifnot(is.character(.groupvar))
    by_group_output <- .dataset %>% 
        dplyr::select_at(dplyr::vars(.groupvar, BMI, 
                                     TotChol, Pulse, BPSysAve, BPDiaAve)) %>% 
        tidyr::gather(Measurement, Value, -.groupvar) %>% 
        na.omit() %>% 
        dplyr::group_by_at(dplyr::vars(.groupvar, Measurement)) %>% 
        dplyr::summarise(Mean = round(mean(Value), 2),
                  SD = round(sd(Value), 2),
                  MeanSD = stringr::str_c(Mean, " (", SD, ")")) %>% 
        dplyr::select(-Mean, -SD) %>% 
        tidyr::spread(.groupvar, MeanSD)
    return(by_group_output)
}
```

### Functions to plot

Let's do this for plots too, since we'll likely be making lots of those! Let's
say we are doing multiple scatter plots, and we've already made a nice theme. 
But we want to create several scatter plots. The non-function code:

```{r scatter-plot}
ggplot(NHANES, aes(x = Height, y = Weight, colour = Gender)) +
    geom_point(size = 2, alpha = 0.3) +
    scale_colour_viridis_d(option = "B", begin = 0.2, end = 0.7) +
    theme_minimal() +
    theme(text = element_text(colour = "grey40"))
```

Like before, maybe we want to see the scatter plot by different variables. So let's 
get it into function form:

```{r plot-function-template, eval=FALSE}
plot_scatter_by_group <- function() {
    scatter_plot <- ggplot(NHANES, aes(x = Height, y = Weight, 
                                       colour = Gender)) +
        geom_point(size = 2, alpha = 0.3) +
        scale_colour_viridis_d(option = "B", begin = 0.2, end = 0.7) +
        theme_minimal() +
        theme(text = element_text(colour = "grey40"))
    return(scatter_plot)
}
```

Then let's add in the arguments.

```{r plot-function-arguments, eval=FALSE}
plot_scatter_by_group <- function(.dataset, .xvar, .yvar, .groupvar) {
    scatter_plot <- ggplot(.dataset, aes(x = .xvar, y = .yvar, 
                                         colour = .groupvar)) +
        geom_point(size = 2, alpha = 0.3) +
        scale_colour_viridis_d(option = "B", begin = 0.2, end = 0.7) +
        theme_minimal() +
        theme(text = element_text(colour = "grey40"))
    return(scatter_plot)
}
```


Like the dplyr code above, this function won't work because it also uses NSE, so
ggplot2 will be confused by the `x = .xvar` since it will think you are asking
for the `.xvar` column in the dataset. So, we need to change `aes()` to
`aes_string()` to force ggplot2 to read `.xvar` as a character string that is
the name of the column you want to plot.

```{r plot-function-aes-string}
plot_scatter_by_group <- function(.dataset, .xvar, .yvar, .groupvar) {
    scatter_plot <- ggplot(.dataset, aes_string(x = .xvar, y = .yvar, 
                                                colour = .groupvar)) +
        geom_point(size = 2, alpha = 0.3) +
        scale_colour_viridis_d(option = "B", begin = 0.2, end = 0.7) +
        theme_minimal() +
        theme(text = element_text(colour = "grey40"))
    return(scatter_plot)
}
plot_scatter_by_group(NHANES, "Height", "Weight", "Gender")
```

Let's add in the `stopifnot`, `ggplot2::` explicit calls, and the roxygen
documentation (`Ctrl-Alt-Shift-R`):

```{r plot-function-finish-up}
#' Create a scatter plot with colouring by categorical variable.
#'
#' @param .dataset Data to plot.
#' @param .xvar Variable for the x axis.
#' @param .yvar Variable for the y axis.
#' @param .groupvar The variable to group/color by.
#'
#' @return Creates a ggplot.
#'
plot_scatter_by_group <- function(.dataset, .xvar, .yvar, .groupvar) {
    stopifnot(is.character(.xvar), is.character(.yvar), is.character(.groupvar))
    scatter_plot <- 
        ggplot2::ggplot(.dataset, ggplot2::aes_string(x = .xvar, y = .yvar, 
                                                      colour = .groupvar)) +
        ggplot2::geom_point(size = 2, alpha = 0.3) +
        ggplot2::scale_colour_viridis_d(option = "B", begin = 0.2, end = 0.7) +
        ggplot2::theme_minimal() +
        ggplot2::theme(text = ggplot2::element_text(colour = "grey40"))
    return(scatter_plot)
}
```

Now we can do other plots easily:

```{r use-plot-function-multiple-times}
plot_scatter_by_group(NHANES, "BMI", "TotChol", "SurveyYr")
plot_scatter_by_group(NHANES, "Poverty", "BMI", "Education")
plot_scatter_by_group(NHANES, "BMI", "BPSysAve", "Diabetes")
```

`r '-->'`
